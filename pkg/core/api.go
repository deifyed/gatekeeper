/*
 * Gatekeeper
 *
 * Handles OIDC authentication for static web apps
 *
 * API version: 0.0.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package core

import (
	"context"
	"fmt"
	"net/http"
	"os"

	"github.com/coreos/go-oidc"
	"github.com/deifyed/gatekeeper/pkg/discovery"
	"github.com/deifyed/gatekeeper/pkg/handlers"
	"github.com/deifyed/gatekeeper/pkg/middleware"
	"github.com/sirupsen/logrus"
	"golang.org/x/oauth2"

	"sigs.k8s.io/yaml"

	"github.com/deifyed/gatekeeper/pkg/config"
	"github.com/deifyed/gatekeeper/pkg/cookies"
	"github.com/deifyed/gatekeeper/pkg/storage/memory"

	"github.com/gin-gonic/gin"
)

// NewRouter returns a new router.
func New(cfg config.Config, specificationYAML []byte) *gin.Engine {
	router := gin.Default()

	logger := &logrus.Logger{
		Out: os.Stdout,
		Formatter: &logrus.JSONFormatter{
			PrettyPrint: true,
		},
		Level: cfg.LogLevel,
	}

	specificationJSON, _ := yaml.YAMLToJSON(specificationYAML)

	stateStorage := memory.New()
	cookieHandler := cookies.NewCookieHandler(cfg.CookiePrefix, cfg.BaseURL.Hostname(), false, true)

	ctx := context.Background()

	discoveryDocument, err := discovery.FetchDiscoveryDocument(cfg.DiscoveryURL)
	if err != nil {
		logger.Fatal(err)
	}

	provider, err := oidc.NewProvider(ctx, discoveryDocument.Issuer)
	if err != nil {
		logger.Fatal(fmt.Errorf("error creating provider: %w", err))
	}

	oauth2Config := oauth2.Config{
		ClientID:     cfg.ClientID,
		ClientSecret: cfg.ClientSecret,
		Endpoint:     provider.Endpoint(),
		RedirectURL:  fmt.Sprintf("%s/callback", cfg.BaseURL.String()),
		Scopes:       []string{oidc.ScopeOpenID, oidc.ScopeOfflineAccess},
	}

	idTokenVerifier := provider.Verifier(&oidc.Config{ClientID: cfg.ClientID})

	router.GET("/", handlers.CreateIndexHandler(cfg.BaseURL))
	router.GET("/specification", func(c *gin.Context) {
		switch c.Request.Header.Get("Accept") {
		case "application/yaml":
			c.Data(http.StatusOK, "application/yaml", specificationYAML)
		default:
			c.Data(http.StatusOK, "application/json", specificationJSON)
		}
	})

	router.GET("/login", handlers.CreateLoginHandler(stateStorage, handlers.CreateLoginHandlerOpts{
		CookieHandler: cookieHandler,
		Logger:        logger,
		Oauth2Config:  oauth2Config,
	}))

	router.GET("/callback", handlers.CreateCallbackHandler(stateStorage, handlers.CreateCallbackHandlerOpts{
		Ctx:           ctx,
		CookieHandler: cookieHandler,
		Logger:        logger,
		Oauth2Config:  oauth2Config,
		TokenVerifier: idTokenVerifier,
	}))

	router.POST("/logout", handlers.CreateLogoutHandler(handlers.CreateLogoutHandlerOpts{
		Logger:         logger,
		LogoutEndpoint: discoveryDocument.EndSessionEndpoint,
		CookieHandler:  cookieHandler,
		ClientID:       cfg.ClientID,
		ClientSecret:   cfg.ClientSecret,
	}))

	router.Use(func(c *gin.Context) {
		refreshMiddleware := middleware.NewTokenRefreshMiddleware(middleware.NewTokenRefreshMiddlewareOpts{
			Logger:        logger,
			CookieHandler: cookieHandler,
			TokenEndpoint: discoveryDocument.TokenEndpoint,
			ClientID:      cfg.ClientID,
			ClientSecret:  cfg.ClientSecret,
		})

		refreshMiddleware.ServeHTTP(c.Writer, c.Request)

		c.Next()
	})

	router.GET("/userinfo", handlers.CreateUserinfoHandler(handlers.CreateUserinfoHandlerOpts{
		Ctx:           ctx,
		CookieHandler: cookieHandler,
		Provider:      provider,
		Logger:        logger,
	}))

	router.Any("/api/:upstream/*realPath", handlers.CreateProxyHandler(handlers.CreateProxyHandlerOpts{
		Logger:        logger,
		CookieHandler: cookieHandler,
		Upstreams:     cfg.Upstreams,
	}))

	return router
}
