/*
 * Gatekeeper
 *
 * Handles OIDC authentication for static web apps
 *
 * API version: 0.0.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */
package handlers

import (
	"fmt"
	"github.com/deifyed/gatekeeper/pkg/core"
	"github.com/google/uuid"
	"net/http"

	"github.com/gin-gonic/gin"
)

const authcodeflowPath = "pkg/core/handlers/authcodeflow.go"

// CreateLoginHandler -
func CreateLoginHandler(storage core.StateStorage, opts CreateLoginHandlerOpts) gin.HandlerFunc {
	logger := opts.Logger.WithFields(map[string]interface{}{
		"file": authcodeflowPath,
		"func": "CreateLoginHandler",
	})

	return func(c *gin.Context) {
		stateID := uuid.New().String()
		state := uuid.New().String()

		err := storage.Put(stateID, state)
		if err != nil {
			logger.Error(fmt.Errorf("error storing state ID: %w", err))

			c.Status(http.StatusInternalServerError)

			return
		}

		opts.CookieHandler.SetStateID(c, stateID)

		c.Redirect(http.StatusFound, opts.Oauth2Config.AuthCodeURL(state))
	}
}

func CreateCallbackHandler(storage core.StateStorage, opts CreateCallbackHandlerOpts) gin.HandlerFunc {
	logger := opts.Logger.WithFields(map[string]interface{}{
		"file": authcodeflowPath,
		"func": "CreateCallbackHandler",
	})

	return func(c *gin.Context) {
		providedState := c.Query("state")
		code := c.Query("code")
		stateID, _ := opts.CookieHandler.GetStateID(c)

		existingState, _ := storage.Get(stateID)
		if providedState != existingState {
			logger.Error("invalid state provided")

			c.Status(http.StatusBadRequest)

			return
		}

		token, err := opts.Oauth2Config.Exchange(opts.Ctx, code)
		if err != nil {
			logger.Error(err)
		}

		rawIDToken, ok := token.Extra("id_token").(string)
		if !ok {
			logger.Errorf("error extracting ID token")
		}

		idToken, err := opts.TokenVerifier.Verify(opts.Ctx, rawIDToken)
		if err != nil {
			logger.Error(err)
		}

		logger.Debug("found idToken: ", idToken)

		opts.CookieHandler.SetAccessToken(c, token.AccessToken, int(token.Expiry.Unix()))
		opts.CookieHandler.SetRefreshToken(c, token.RefreshToken)
		opts.CookieHandler.SetIDToken(c, rawIDToken)

		c.Redirect(http.StatusFound, "http://localhost:8080")
	}
}

func CreateUserinfoHandler(opts CreateUserinfoHandlerOpts) gin.HandlerFunc {
	logger := opts.Logger.WithFields(map[string]interface{}{
		"file": authcodeflowPath,
		"func": "CreateUserinfoHandler",
	})

	return func(c *gin.Context) {
		tokenSource := newTokenGetter(opts.CookieHandler, c)

		userinfo, err := opts.Provider.UserInfo(opts.Ctx, tokenSource)
		if err != nil {
			logger.Warn(fmt.Errorf("error getting userinfo: %w", err))

			c.Status(http.StatusInternalServerError)

			return
		}

		c.JSON(http.StatusOK, userinfo)
	}
}
